// Generated by jextract

package tech.bitey.golpanama.xlib;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class _XImage {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_INT$LAYOUT.withName("width"),
        Constants$root.C_INT$LAYOUT.withName("height"),
        Constants$root.C_INT$LAYOUT.withName("xoffset"),
        Constants$root.C_INT$LAYOUT.withName("format"),
        Constants$root.C_POINTER$LAYOUT.withName("data"),
        Constants$root.C_INT$LAYOUT.withName("byte_order"),
        Constants$root.C_INT$LAYOUT.withName("bitmap_unit"),
        Constants$root.C_INT$LAYOUT.withName("bitmap_bit_order"),
        Constants$root.C_INT$LAYOUT.withName("bitmap_pad"),
        Constants$root.C_INT$LAYOUT.withName("depth"),
        Constants$root.C_INT$LAYOUT.withName("bytes_per_line"),
        Constants$root.C_INT$LAYOUT.withName("bits_per_pixel"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_LONG_LONG$LAYOUT.withName("red_mask"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("green_mask"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("blue_mask"),
        Constants$root.C_POINTER$LAYOUT.withName("obdata"),
        MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("create_image"),
            Constants$root.C_POINTER$LAYOUT.withName("destroy_image"),
            Constants$root.C_POINTER$LAYOUT.withName("get_pixel"),
            Constants$root.C_POINTER$LAYOUT.withName("put_pixel"),
            Constants$root.C_POINTER$LAYOUT.withName("sub_image"),
            Constants$root.C_POINTER$LAYOUT.withName("add_pixel")
        ).withName("f")
    ).withName("_XImage");
    public static MemoryLayout $LAYOUT() {
        return _XImage.$struct$LAYOUT;
    }
    static final VarHandle width$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("width"));
    public static VarHandle width$VH() {
        return _XImage.width$VH;
    }
    public static int width$get(MemorySegment seg) {
        return (int)_XImage.width$VH.get(seg);
    }
    public static void width$set( MemorySegment seg, int x) {
        _XImage.width$VH.set(seg, x);
    }
    public static int width$get(MemorySegment seg, long index) {
        return (int)_XImage.width$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void width$set(MemorySegment seg, long index, int x) {
        _XImage.width$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle height$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("height"));
    public static VarHandle height$VH() {
        return _XImage.height$VH;
    }
    public static int height$get(MemorySegment seg) {
        return (int)_XImage.height$VH.get(seg);
    }
    public static void height$set( MemorySegment seg, int x) {
        _XImage.height$VH.set(seg, x);
    }
    public static int height$get(MemorySegment seg, long index) {
        return (int)_XImage.height$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void height$set(MemorySegment seg, long index, int x) {
        _XImage.height$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle xoffset$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("xoffset"));
    public static VarHandle xoffset$VH() {
        return _XImage.xoffset$VH;
    }
    public static int xoffset$get(MemorySegment seg) {
        return (int)_XImage.xoffset$VH.get(seg);
    }
    public static void xoffset$set( MemorySegment seg, int x) {
        _XImage.xoffset$VH.set(seg, x);
    }
    public static int xoffset$get(MemorySegment seg, long index) {
        return (int)_XImage.xoffset$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void xoffset$set(MemorySegment seg, long index, int x) {
        _XImage.xoffset$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle format$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("format"));
    public static VarHandle format$VH() {
        return _XImage.format$VH;
    }
    public static int format$get(MemorySegment seg) {
        return (int)_XImage.format$VH.get(seg);
    }
    public static void format$set( MemorySegment seg, int x) {
        _XImage.format$VH.set(seg, x);
    }
    public static int format$get(MemorySegment seg, long index) {
        return (int)_XImage.format$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void format$set(MemorySegment seg, long index, int x) {
        _XImage.format$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle data$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("data"));
    public static VarHandle data$VH() {
        return _XImage.data$VH;
    }
    public static MemoryAddress data$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_XImage.data$VH.get(seg);
    }
    public static void data$set( MemorySegment seg, MemoryAddress x) {
        _XImage.data$VH.set(seg, x);
    }
    public static MemoryAddress data$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_XImage.data$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void data$set(MemorySegment seg, long index, MemoryAddress x) {
        _XImage.data$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle byte_order$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("byte_order"));
    public static VarHandle byte_order$VH() {
        return _XImage.byte_order$VH;
    }
    public static int byte_order$get(MemorySegment seg) {
        return (int)_XImage.byte_order$VH.get(seg);
    }
    public static void byte_order$set( MemorySegment seg, int x) {
        _XImage.byte_order$VH.set(seg, x);
    }
    public static int byte_order$get(MemorySegment seg, long index) {
        return (int)_XImage.byte_order$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void byte_order$set(MemorySegment seg, long index, int x) {
        _XImage.byte_order$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle bitmap_unit$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bitmap_unit"));
    public static VarHandle bitmap_unit$VH() {
        return _XImage.bitmap_unit$VH;
    }
    public static int bitmap_unit$get(MemorySegment seg) {
        return (int)_XImage.bitmap_unit$VH.get(seg);
    }
    public static void bitmap_unit$set( MemorySegment seg, int x) {
        _XImage.bitmap_unit$VH.set(seg, x);
    }
    public static int bitmap_unit$get(MemorySegment seg, long index) {
        return (int)_XImage.bitmap_unit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bitmap_unit$set(MemorySegment seg, long index, int x) {
        _XImage.bitmap_unit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle bitmap_bit_order$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bitmap_bit_order"));
    public static VarHandle bitmap_bit_order$VH() {
        return _XImage.bitmap_bit_order$VH;
    }
    public static int bitmap_bit_order$get(MemorySegment seg) {
        return (int)_XImage.bitmap_bit_order$VH.get(seg);
    }
    public static void bitmap_bit_order$set( MemorySegment seg, int x) {
        _XImage.bitmap_bit_order$VH.set(seg, x);
    }
    public static int bitmap_bit_order$get(MemorySegment seg, long index) {
        return (int)_XImage.bitmap_bit_order$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bitmap_bit_order$set(MemorySegment seg, long index, int x) {
        _XImage.bitmap_bit_order$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle bitmap_pad$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bitmap_pad"));
    public static VarHandle bitmap_pad$VH() {
        return _XImage.bitmap_pad$VH;
    }
    public static int bitmap_pad$get(MemorySegment seg) {
        return (int)_XImage.bitmap_pad$VH.get(seg);
    }
    public static void bitmap_pad$set( MemorySegment seg, int x) {
        _XImage.bitmap_pad$VH.set(seg, x);
    }
    public static int bitmap_pad$get(MemorySegment seg, long index) {
        return (int)_XImage.bitmap_pad$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bitmap_pad$set(MemorySegment seg, long index, int x) {
        _XImage.bitmap_pad$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle depth$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("depth"));
    public static VarHandle depth$VH() {
        return _XImage.depth$VH;
    }
    public static int depth$get(MemorySegment seg) {
        return (int)_XImage.depth$VH.get(seg);
    }
    public static void depth$set( MemorySegment seg, int x) {
        _XImage.depth$VH.set(seg, x);
    }
    public static int depth$get(MemorySegment seg, long index) {
        return (int)_XImage.depth$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void depth$set(MemorySegment seg, long index, int x) {
        _XImage.depth$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle bytes_per_line$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bytes_per_line"));
    public static VarHandle bytes_per_line$VH() {
        return _XImage.bytes_per_line$VH;
    }
    public static int bytes_per_line$get(MemorySegment seg) {
        return (int)_XImage.bytes_per_line$VH.get(seg);
    }
    public static void bytes_per_line$set( MemorySegment seg, int x) {
        _XImage.bytes_per_line$VH.set(seg, x);
    }
    public static int bytes_per_line$get(MemorySegment seg, long index) {
        return (int)_XImage.bytes_per_line$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bytes_per_line$set(MemorySegment seg, long index, int x) {
        _XImage.bytes_per_line$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle bits_per_pixel$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("bits_per_pixel"));
    public static VarHandle bits_per_pixel$VH() {
        return _XImage.bits_per_pixel$VH;
    }
    public static int bits_per_pixel$get(MemorySegment seg) {
        return (int)_XImage.bits_per_pixel$VH.get(seg);
    }
    public static void bits_per_pixel$set( MemorySegment seg, int x) {
        _XImage.bits_per_pixel$VH.set(seg, x);
    }
    public static int bits_per_pixel$get(MemorySegment seg, long index) {
        return (int)_XImage.bits_per_pixel$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void bits_per_pixel$set(MemorySegment seg, long index, int x) {
        _XImage.bits_per_pixel$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle red_mask$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("red_mask"));
    public static VarHandle red_mask$VH() {
        return _XImage.red_mask$VH;
    }
    public static long red_mask$get(MemorySegment seg) {
        return (long)_XImage.red_mask$VH.get(seg);
    }
    public static void red_mask$set( MemorySegment seg, long x) {
        _XImage.red_mask$VH.set(seg, x);
    }
    public static long red_mask$get(MemorySegment seg, long index) {
        return (long)_XImage.red_mask$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void red_mask$set(MemorySegment seg, long index, long x) {
        _XImage.red_mask$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle green_mask$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("green_mask"));
    public static VarHandle green_mask$VH() {
        return _XImage.green_mask$VH;
    }
    public static long green_mask$get(MemorySegment seg) {
        return (long)_XImage.green_mask$VH.get(seg);
    }
    public static void green_mask$set( MemorySegment seg, long x) {
        _XImage.green_mask$VH.set(seg, x);
    }
    public static long green_mask$get(MemorySegment seg, long index) {
        return (long)_XImage.green_mask$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void green_mask$set(MemorySegment seg, long index, long x) {
        _XImage.green_mask$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle blue_mask$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("blue_mask"));
    public static VarHandle blue_mask$VH() {
        return _XImage.blue_mask$VH;
    }
    public static long blue_mask$get(MemorySegment seg) {
        return (long)_XImage.blue_mask$VH.get(seg);
    }
    public static void blue_mask$set( MemorySegment seg, long x) {
        _XImage.blue_mask$VH.set(seg, x);
    }
    public static long blue_mask$get(MemorySegment seg, long index) {
        return (long)_XImage.blue_mask$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void blue_mask$set(MemorySegment seg, long index, long x) {
        _XImage.blue_mask$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle obdata$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("obdata"));
    public static VarHandle obdata$VH() {
        return _XImage.obdata$VH;
    }
    public static MemoryAddress obdata$get(MemorySegment seg) {
        return (jdk.incubator.foreign.MemoryAddress)_XImage.obdata$VH.get(seg);
    }
    public static void obdata$set( MemorySegment seg, MemoryAddress x) {
        _XImage.obdata$VH.set(seg, x);
    }
    public static MemoryAddress obdata$get(MemorySegment seg, long index) {
        return (jdk.incubator.foreign.MemoryAddress)_XImage.obdata$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void obdata$set(MemorySegment seg, long index, MemoryAddress x) {
        _XImage.obdata$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static class funcs {

        static final  GroupLayout funcs$struct$LAYOUT = MemoryLayout.structLayout(
            Constants$root.C_POINTER$LAYOUT.withName("create_image"),
            Constants$root.C_POINTER$LAYOUT.withName("destroy_image"),
            Constants$root.C_POINTER$LAYOUT.withName("get_pixel"),
            Constants$root.C_POINTER$LAYOUT.withName("put_pixel"),
            Constants$root.C_POINTER$LAYOUT.withName("sub_image"),
            Constants$root.C_POINTER$LAYOUT.withName("add_pixel")
        ).withName("funcs");
        public static MemoryLayout $LAYOUT() {
            return funcs.funcs$struct$LAYOUT;
        }
        static final FunctionDescriptor create_image$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT
        );
        static final MethodHandle create_image$MH = RuntimeHelper.downcallHandle(
            funcs.create_image$FUNC, false
        );
        public interface create_image {

            jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, int x3, int x4, jdk.incubator.foreign.MemoryAddress x5, int x6, int x7, int x8, int x9);
            static NativeSymbol allocate(create_image fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(create_image.class, fi, funcs.create_image$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IIILjdk/incubator/foreign/MemoryAddress;IIII)Ljdk/incubator/foreign/Addressable;", scope);
            }
            static create_image ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("create_image::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, jdk.incubator.foreign.MemoryAddress x1, int x2, int x3, int x4, jdk.incubator.foreign.MemoryAddress x5, int x6, int x7, int x8, int x9) -> {
                    try {
                        return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)funcs.create_image$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, (jdk.incubator.foreign.Addressable)x1, x2, x3, x4, (jdk.incubator.foreign.Addressable)x5, x6, x7, x8, x9);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle create_image$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("create_image"));
        public static VarHandle create_image$VH() {
            return funcs.create_image$VH;
        }
        public static MemoryAddress create_image$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.create_image$VH.get(seg);
        }
        public static void create_image$set( MemorySegment seg, MemoryAddress x) {
            funcs.create_image$VH.set(seg, x);
        }
        public static MemoryAddress create_image$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.create_image$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void create_image$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.create_image$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static create_image create_image (MemorySegment segment, ResourceScope scope) {
            return create_image.ofAddress(create_image$get(segment), scope);
        }
        static final FunctionDescriptor destroy_image$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
            Constants$root.C_POINTER$LAYOUT
        );
        static final MethodHandle destroy_image$MH = RuntimeHelper.downcallHandle(
            funcs.destroy_image$FUNC, false
        );
        public interface destroy_image {

            int apply(jdk.incubator.foreign.MemoryAddress x0);
            static NativeSymbol allocate(destroy_image fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(destroy_image.class, fi, funcs.destroy_image$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
            }
            static destroy_image ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("destroy_image::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0) -> {
                    try {
                        return (int)funcs.destroy_image$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle destroy_image$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("destroy_image"));
        public static VarHandle destroy_image$VH() {
            return funcs.destroy_image$VH;
        }
        public static MemoryAddress destroy_image$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.destroy_image$VH.get(seg);
        }
        public static void destroy_image$set( MemorySegment seg, MemoryAddress x) {
            funcs.destroy_image$VH.set(seg, x);
        }
        public static MemoryAddress destroy_image$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.destroy_image$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void destroy_image$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.destroy_image$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static destroy_image destroy_image (MemorySegment segment, ResourceScope scope) {
            return destroy_image.ofAddress(destroy_image$get(segment), scope);
        }
        static final FunctionDescriptor get_pixel$FUNC = FunctionDescriptor.of(Constants$root.C_LONG_LONG$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT
        );
        static final MethodHandle get_pixel$MH = RuntimeHelper.downcallHandle(
            funcs.get_pixel$FUNC, false
        );
        public interface get_pixel {

            long apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2);
            static NativeSymbol allocate(get_pixel fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(get_pixel.class, fi, funcs.get_pixel$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;II)J", scope);
            }
            static get_pixel ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("get_pixel::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2) -> {
                    try {
                        return (long)funcs.get_pixel$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle get_pixel$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("get_pixel"));
        public static VarHandle get_pixel$VH() {
            return funcs.get_pixel$VH;
        }
        public static MemoryAddress get_pixel$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.get_pixel$VH.get(seg);
        }
        public static void get_pixel$set( MemorySegment seg, MemoryAddress x) {
            funcs.get_pixel$VH.set(seg, x);
        }
        public static MemoryAddress get_pixel$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.get_pixel$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void get_pixel$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.get_pixel$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static get_pixel get_pixel (MemorySegment segment, ResourceScope scope) {
            return get_pixel.ofAddress(get_pixel$get(segment), scope);
        }
        static final FunctionDescriptor put_pixel$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_LONG_LONG$LAYOUT
        );
        static final MethodHandle put_pixel$MH = RuntimeHelper.downcallHandle(
            funcs.put_pixel$FUNC, false
        );
        public interface put_pixel {

            int apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, long x3);
            static NativeSymbol allocate(put_pixel fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(put_pixel.class, fi, funcs.put_pixel$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;IIJ)I", scope);
            }
            static put_pixel ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("put_pixel::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, long x3) -> {
                    try {
                        return (int)funcs.put_pixel$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2, x3);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle put_pixel$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("put_pixel"));
        public static VarHandle put_pixel$VH() {
            return funcs.put_pixel$VH;
        }
        public static MemoryAddress put_pixel$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.put_pixel$VH.get(seg);
        }
        public static void put_pixel$set( MemorySegment seg, MemoryAddress x) {
            funcs.put_pixel$VH.set(seg, x);
        }
        public static MemoryAddress put_pixel$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.put_pixel$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void put_pixel$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.put_pixel$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static put_pixel put_pixel (MemorySegment segment, ResourceScope scope) {
            return put_pixel.ofAddress(put_pixel$get(segment), scope);
        }
        static final FunctionDescriptor sub_image$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT,
            Constants$root.C_INT$LAYOUT
        );
        static final MethodHandle sub_image$MH = RuntimeHelper.downcallHandle(
            funcs.sub_image$FUNC, false
        );
        public interface sub_image {

            jdk.incubator.foreign.Addressable apply(jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, int x3, int x4);
            static NativeSymbol allocate(sub_image fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(sub_image.class, fi, funcs.sub_image$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;IIII)Ljdk/incubator/foreign/Addressable;", scope);
            }
            static sub_image ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("sub_image::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, int x1, int x2, int x3, int x4) -> {
                    try {
                        return (jdk.incubator.foreign.Addressable)(jdk.incubator.foreign.MemoryAddress)funcs.sub_image$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1, x2, x3, x4);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle sub_image$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("sub_image"));
        public static VarHandle sub_image$VH() {
            return funcs.sub_image$VH;
        }
        public static MemoryAddress sub_image$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.sub_image$VH.get(seg);
        }
        public static void sub_image$set( MemorySegment seg, MemoryAddress x) {
            funcs.sub_image$VH.set(seg, x);
        }
        public static MemoryAddress sub_image$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.sub_image$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void sub_image$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.sub_image$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static sub_image sub_image (MemorySegment segment, ResourceScope scope) {
            return sub_image.ofAddress(sub_image$get(segment), scope);
        }
        static final FunctionDescriptor add_pixel$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
            Constants$root.C_POINTER$LAYOUT,
            Constants$root.C_LONG_LONG$LAYOUT
        );
        static final MethodHandle add_pixel$MH = RuntimeHelper.downcallHandle(
            funcs.add_pixel$FUNC, false
        );
        public interface add_pixel {

            int apply(jdk.incubator.foreign.MemoryAddress x0, long x1);
            static NativeSymbol allocate(add_pixel fi, ResourceScope scope) {
                return RuntimeHelper.upcallStub(add_pixel.class, fi, funcs.add_pixel$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;J)I", scope);
            }
            static add_pixel ofAddress(MemoryAddress addr, ResourceScope scope) {
                NativeSymbol symbol = NativeSymbol.ofAddress("add_pixel::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (jdk.incubator.foreign.MemoryAddress x0, long x1) -> {
                    try {
                        return (int)funcs.add_pixel$MH.invokeExact(symbol, (jdk.incubator.foreign.Addressable)x0, x1);
                    } catch (Throwable ex$) {
                        throw new AssertionError("should not reach here", ex$);
                    }
                };
            }
        }

        static final VarHandle add_pixel$VH = funcs$struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("add_pixel"));
        public static VarHandle add_pixel$VH() {
            return funcs.add_pixel$VH;
        }
        public static MemoryAddress add_pixel$get(MemorySegment seg) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.add_pixel$VH.get(seg);
        }
        public static void add_pixel$set( MemorySegment seg, MemoryAddress x) {
            funcs.add_pixel$VH.set(seg, x);
        }
        public static MemoryAddress add_pixel$get(MemorySegment seg, long index) {
            return (jdk.incubator.foreign.MemoryAddress)funcs.add_pixel$VH.get(seg.asSlice(index*sizeof()));
        }
        public static void add_pixel$set(MemorySegment seg, long index, MemoryAddress x) {
            funcs.add_pixel$VH.set(seg.asSlice(index*sizeof()), x);
        }
        public static add_pixel add_pixel (MemorySegment segment, ResourceScope scope) {
            return add_pixel.ofAddress(add_pixel$get(segment), scope);
        }
        public static long sizeof() { return $LAYOUT().byteSize(); }
        public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
        public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
        }
        public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
        public static MemorySegment allocateArray(int len, ResourceScope scope) {
            return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
        }
        public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
    }

    public static MemorySegment f$slice(MemorySegment seg) {
        return seg.asSlice(88, 48);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


